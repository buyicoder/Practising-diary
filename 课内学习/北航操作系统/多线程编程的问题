多线程编程会碰到竞争条件的问题。

竞争条件指的是多个进程同时读写共享数据，最后的结果取决于进程运行的精确时序，如果不加以限制，会导致程序出现不确定的结果，就会有bug。

那么我们应该如何避免竞争条件呢？其实，只要多个进程拥有共享内存，并且至少有一个进程含有写操作，就会产生竞争条件的问题。问题的根本在于多个进程同时使用共享数据。

那么我们就需要避免多个进程同时使用共享数据，这个操作叫做互斥。我们把对共享内存进行访问的程序片段称作**临界区域**。互斥，就是要避免多个进程同时处于临界区。

科学家们想出了多种解决方案。

- 首先就是屏蔽中断，一个进程在访问临界区的时候屏蔽中断，不允许切换进程，这样就杜绝了切换到另一个也在临界区的进程的可能。这个办法是有效的，但是让用户屏蔽中断的危险的（鬼知道用户会写出什么程序，一不小心就死机了），所以这个方法不好。

- 然后就是使用锁变量。锁变量就是标记当前临界区是否有进程，如果没有直接进入，如果有就等待。但是锁变量的问题是锁变量本身就是共享数据，使用锁变量的时候可能导致竞争条件的问题。或者说使用锁变量会导致临界区扩大，而为了互斥新增的临界区又需要新的锁变量，如此下去无限循环，这个方法是无效的。

- 严格轮换法。使用一个自旋锁，记录轮到哪个进程了。如果没轮到就忙等待。

**忙等待**的意思是连续测试一个变量直到某个值出现为止

```C++
while(TRUE){
	while(turn != 0 ){
		critical_region();
		turn = 1;
		noncritical_region();
	}
}
```

```C++
while(TRUE){
	while(turn != 1 ){
		critical_region();
		turn = 0;
		noncritical_region();
	}
}
```

 缺点是只能严格轮换，进程1访问了临界区之后，必须要等进程2访问一次临界区，进程1才能再次访问，非常不方便。

- Peterson解法

  ```C++
  #define FALSE 0
  #define TRUE 1
  #define N 2
  int turn;
  int interested[N]
  
  void enter_region(int process)
  {
  	int other;
  	
  	other = 1-process;
  	interested[process] = TRUE;
  	turn = process;
  	while(turn == process && interested[other]==TRUE);
  }
  void leave_region(int process)
  {
  	interested[process] = FALSE;
  }
  ```

  Peterson解法是有效的但是还是有忙等待的缺点

- TSL指令和XCHG指令

- 睡眠和唤醒+信号量+原语

  这个办法可以以说是竞争条件的终极解决办法，没有忙等待，而且是有效的。

  前面的解决办法基本都是忙等待的，都没有阻塞进程，但是还有效率更高的办法，无法进入临界区的进程，我们直接阻塞它，让它在等待的时候不占用CPU资源，这就需要睡眠和唤醒（sleep&wakeup），睡眠就是阻塞进程，唤醒就是让该进程重新进入就绪队列。唤醒是需要原本占用着共享资源的进程来做的。睡眠和唤醒是两种系统调用，很明显唤醒是一种进程间通信。

  我们需要信号量来判断什么时候睡眠，什么时候唤醒，信号量和普通变量的区别就在于，==对信号量的所有操作都得是原子操作==，down和up。

  - down操作：判断信号量是否大于0，若是，-1继续，若不是，进程将睡眠，而且该进程会进入该信号量的睡眠队列。
  - up操作：对信号量的值+1，如果一个或多个进程在该信号量上睡眠（说明原本信号量为0），随机挑选一个唤醒并允许该进程完成它的down操作（这样信号量又回到0了）

- 