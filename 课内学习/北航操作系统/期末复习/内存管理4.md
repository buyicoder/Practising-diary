# 内存管理4

## 页面置换算法

- 最佳算法
- 最近未使用页面置换算法NRU
- 先进先出算法
  - Belady现象：缺页率随页框数增加反而上升
- 二次机会页面置换算法对FIFO的改进
- 时钟算法，对二次机会算法的改进，逻辑一模一样
- 最近最久不用的页面置换算法
  - 多种实现方式
    - 使用堆栈结构存储页面
    - 每个页面移位寄存器
    - 每个页面设置自增计数器，每条指令都自增
- 最不常用算法：每次访问页面计数器+1，记录访问次数，置换访问次数最少的页面
  - 缺点：早期访问次数多的页面“吃老本”
- Aging算法：对LER的近似，每个页面一个计数器，每周期计数器右移一位，R位添加到最左边
  - 右移解决了最不常用算法的吃老本问题
  - 新的问题：只能记录最近几个周期的访问信息
- 页面缓冲算法：对FIFO算法的发展
  - 把被置换的页面放入两个链表之一
    - 未修改页面链表
    - 已修改页面链表
  - 已修改页面达到一定数目后，再一起调出到外存，然后归入空闲页面链表
  - 需要调入新的物理页面时，将新页面内容读入空闲链表第一项，然后将第一项删除。
- 工作集策略：淘汰不在工作集的页面
  - 某个进程在某一时刻，最近k次访问过的页面称为该进程的工作集W(k,t)
  - 一个页面可能在同一时刻属于两个工作集，当这个页面被多个进程共享的时候是有可能的
  - 使用时间间隔作为最近k次访问的近似
    - 最近一千万次访问的页---最近100ms访问的页面
  - 每个页表记录了上次访问时间
  - 周期性的时钟中断会重置R访问位
  - 如果R==1，说明在当前时钟周期就访问了该页面，要更新上次访问时间
  - 如果R==0，计算Age，和工作集定义的时间做比较
- 时钟工作集算法
  - 保存页框循环链表，而不是扫描整个页表（页框的数量比页表项少很多，节约了时间也节约了空间）（而且既然是扫描页框，说明肯定要维护一个反向页表的，即可以通过反向页表找到，正在使用该页框的页表项）
  - 如果走了一圈还没有找到工作集外的页框，说明都在工作集之内，随便找一个干净页面替换，如果没有干净页面，写回并替换当前页

