# 进程和线程

进程之间有很大的独立性，而且有竞争性。

而线程具有合作性，有完全一样的地址空间



#### 进程中的内容（线程共享的内容）

- 地址空间
- 全局变量
- 打开文件
- 子进程
- 即将发生的定时器
- 信号与信号处理程序
- 账户信息

#### 线程自己的内容

- 程序计数器
- 寄存器
- 堆栈
- 状态



线程有自己的堆栈，这里堆栈的作用其实就是平时写汇编的那个堆栈迭代的作用，用于调用函数，调用函数之前要开辟空间，然后放栈帧。栈帧里面是当前过程用到的局部变量和返回的地址。

多线程通常由单线程开始，这个线程通过调用库函数创建新的线程。但是线程之间是平等的。创建新线程的时候不用规定地址空间，因为新线程会自动在创建线程的地址空间运行。这都是车轱辘话，前面说过了线程有完全一样的地址空间，而且不用开地址空间也是为什么线程比进程轻量级的原因。

线程增加的程序设计的复杂性（当然，多线程肯定比单线程难编）但是这些新问题是可以解决的



### POSIX线程

线程的标准

pthread。

所有线程都有的特性：一个标识符，一组寄存器，一组存储在结构中的属性。

#### 六个线程调用

- pthread_create 创建新线程
- pthread_exit结束调用的线程
- pthread_join等待一个特定的线程退出
- pthread_yield释放CPU来运行另外一个线程
- pthread_attr_init创建并初始化一个线程的属性结构
- pthread_attr_destroy删除一个线程的属性结构



属性结构有什么用？



### 在用户空间中实现线程

两种主要的方法实现线程包：在用户空间中和在内核中。

这里就需要理解。现在我看的书多了也就理解了。很多东西是先有概念再有实现的。

进程和线程也是这样，是先有概念，然后再通过硬件和软件去实现。而实现的方法有成千上万种，一千个人有一千哈姆雷特。

在用户空间中实现就是说和函数一样，这个线程包就是一个函数库，而操作系统不知道线程的概念

在用户空间中管理线程时，每个进程需要有其专用的线程表，用来跟踪该进程中的线程。

用户级线程包有更好的性能，而且更灵活，可以有自己的调度算法。

但是无法实现阻塞系统调用。因为一但用了阻塞系统调用，所有的线程都要停下来。

阻塞系统调用是什么？就是等待键盘输入或者别的输入。S

还有缺页中断问题

总之有很多问题