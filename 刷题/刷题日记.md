# 刷题日记

## 手动实现sqrt函数

### 什么是牛顿迭代法？

给定一个函数，求其零点。

方法：先随便取一个点$p_0$

然后求$p_1=p_0-\dfrac{f(p_0)}{f^{\prime}(p_0)}$

再将$p1$代回求$p2$，最终$p_n$会收敛至零点

所以求$A$的平方根相当于求函数$f(x)=x^2-A$的零点

$f^{\prime}(x)=2x$

取$p_0=A$

然后一直迭代，直到$p_i-p_{i-1}<1$

### 找出唯一的数2.0

一列数组中，有一个数只出现一次，其它数均出现3次，如何用在线性时间内，常数空间内求出唯一的数？

这个问题原来没有搞太清楚，就是用异或的方法。

用异或的时候没有搞清楚本质，只是感觉很妙，现在写了三个的已经彻底搞清楚了。

其实就是要记录，一个数出现了几次，出现三次自动归零。

所以这里模拟三进制就好

其实本质是用一个状态机记录32位数的状态，出现三次自动归零

2024.11.30

###  分隔链表

- 判断当前数，小数or大数

- 找交界点1和交界点2和交界点3
- 1前指向2后，3前指向1后，2前指向3后
- 3前1后变为新交界点1，从3后继续寻找交界点
- 停止条件：1后huo2后为NULL，导致没有交界点3
- 交界点的判断，前后为不同性质的Node，共三种性质，val<x,val>=x,NULL

#### LRU缓存

使用双向链表和哈希表存数据，哈希表的值为链表节点地址

链表的最后是最少使用的数据

- put操作
  - 判断是否已经存在，
    - 若存在，修改链表中value的值，同时抽出后将该节点放到最前面
    - 若不存在，创建节点放到最前面，加入到哈希表，然后检查节点数量，若超出capacity，删去最后的节点，==删除键值对==

- get操作
  - 判断是否存在
    - 若存在，抽出后将该节点放到最前面，返回键
    - 若不存在，返回-1



#### debug过程：

- 首先打错字母导致的编译错误
- 然后是创建类的时候出现错误，原因是创建类的时候一定要严格按照构造函数的格式，可以重载构造函数，没有的时候默认capacity为0，但是代码里面没写，只有给了capacity的函数，所以报错了。学到了，对类的用法更清晰了。
- 然后删除了节点但是没有删除umap中的键值对，这一点在考虑步骤的时候就忽略了
- 学到了比较好的书写构造函数的写法，打一个冒号，然后列出要更新的值，写在小括号里面就行
- 然后unorderd_map的值可以有多个吗？

### C++queue用法

.push()

.pop()移除开头元素

.front()和.end()分别访问队列开头和末尾的元素

.size()检查队列大小

.empty()检查是否为空

### 二叉树展开为链表

- 若右孩子不为NULL，展开右孩子，

- 若左孩子不为NULL，展开左孩子，否则直接返回
- 寻找左孩子尾结点

- 左孩子尾节点连接右孩子

- 左孩子转到右孩子：right=left，left==NULL

### 求根节点到叶节点数字之和

遍历每个叶节点，求出每个叶节点数字，相加

问题是如何在一遍历的时候记录就把每个叶节点数字相加

### 二叉树中的最大路径和

### 二叉树的非递归遍历

==一定会用到栈==

#### 前序遍历

while（栈不为空或者p不为NULL）{

​			将p一直进入左子树

​			访问经过的节点

​			访问过的节点都入栈			

​			到底了之后

​			该进入右子树了

​			pop出来，

​			进入右孩子

}

#### 二叉搜索树

中序遍历就是从小到大排列的



#### 复习图的遍历

广度优先：

使用一个哈希表记录当前顶点是否被访问过

当前顶点入队

while（队不为空）{

- 出队

- 判断是否访问过，访问过则进入下一循环
- 访问
- 更新哈希表
- 将该节点所有邻居入队

}



深度优先：

使用一个哈希表记录当前顶点是否被访问

访问当前顶点

当前顶点入栈

while（栈不为空）{

- 出栈
- 判断每个邻居是否访问过，如果没有，进行访问，将当前顶点入栈，进入该邻居节点
- 入栈
- 进入

}

#### C++pair的使用方法

pair是将两个数据组合成一个数据

是一个结构体

```
pair<T1,T2> p1;
pair<T1,T2> p1(v1,v2);
make_pair(v1,v2);
p1<p2;
p1.first
p2.second
```

#### 除法求值

- 使用hash表有向图，键为字母，值为点数组和边数组的pair，边数组是下标，指向传进来的equation。

- 遍历question

  - 如果有a和c不在哈希表中，返回-1.0

  - 从a开始广度遍历，同时计算从a到当前结点的值，直到找到c，返回该值，若未找到，返回-1.0

广度遍历的过程：

使用一个哈希表记录当前顶点是否被访问过

a顶点入队

temp表示临时值

while（队不为空）{

- 出队

- 判断是否访问过，访问过则进入下一循环
- 如果是a，temp=1
- 如果不是a，temp=temp*/value【index】根据a边方向判断乘除
- 如果是c直接返回temp
- 更新哈希表
- 将该节点所有邻居入队

}

到这里说明没找到，返回-1.0

#### 课程表

记录分别每个点的入点、入度和出点、出度

用delete数组记录该点是否删除

进入循环

- 遍历所有点，寻找入度为0的点，删除该点，该点的出点的入度减一

如果没有可删除的点，跳出循环

看是否所有点被删除

#### 快速排序

找到一个元素，把比它小的都放到左边，比它大的都放到右边，然后分别排两边

#### 对链表进行归并排序

如果有两部分已经排好的数组，那么就选两部分更小的那个放进数组，更新下标之后继续。

快慢指针找到中位点

分出两条链

递归对左链和右链进行排序

合并左链和右链

- 定义一个tempHead结点
- while()

### 图的最短路径问题

Dijkstra算法

- 设置两点顶点的集合U和T，集合U中存放已经找到最短路径的顶点，集合T中存放当前还未找到的最短路径的顶点。

- 初始状态时，集合U中只包含源点，设为$v_0$
- 然后从集合T中选择最短的顶点u加入到U中
- 集合U中每加入一个新的顶点u都要修改源点$v_0$带集合T中剩余顶点的当前最短路径值，集合T中各顶点的新的当前最短路径长度值，为原来的当前最短路径长度值与从源点过顶点u到达该顶点的带权路径长度的较小者

### 优先队列priority_queue

```
priority_queue<Type,Container,Functional>
```

### C++的operator

C++使用operator重载运算符

operater和运算符一起使用，表示一个运算符重载函数，在理解时可将operator和待重载的运算符整体视为一个函数名

operator（）的意思时把括号重载了，这样调用tmp2的时候会用tmp2（）

把括号重载了

### 仿函数

仿函数其实就是重载了operator（）运算符的类对象

```
如
struct MyPlus{
	int operator()(const int &a, const int &b) const{
		return a+b;
	}
};

有多种调用方法：
1.cout<<MyPlus(1，2)<<endl;
2.cout<<a.operator()(1,2)<<endl;
3.cout<<a(1,2)<<endl;
```

正是因为有一这种调用方法，使得这个结构体或者说类和函数看上去没什么区别了，所以叫做仿函数，本质是用operator把括号给重载掉了。

### 可调用对象

```
[[-1,11,6,-1],
[-1,15,16,-1],
[-1,7,-1,8],
[-1,-1,-1,8]]
```





### 函数指针

函数指针即一个指向函数的指针变量，定义的格式“

```
int (*p)(int x,int y);
```

对应函数指针类型

定义了之后这个函数就可以通过指针调用

```
int maxValue(int a , int b){
	return a>b ? a : b;
}
int (*p)(int, int)=NULL;
p=maxValue;
p(20,45);
```

如何确定指针变量的类别很重要，可以使用

```
typeid(variable).name();
```

### 函数也可以作为参数





### template

C++是强类型语言，template提供泛化编程的可能。

就是说，有可能传进的参数类型有很多个，但是传进去之前不确定，这时候就可以用template

### 虚函数

### 红黑树

- 书上的每个结点只能是红色或黑色
- 根节点一定是黑色
- 叶子结点一定是黑色的空值节点（NULL）
- 任一路径上不能有两个连续的红色节点
- 从任何节点出发，其下至叶节点所有路径的黑色节点数目相同

插入操作一边有五种情况，插入的节点默认是红色，因为如果插入黑色，必然导致黑色节点数量大于其它路径上的黑色节点

- 情况1：红黑树为空树，插入节点成为根节点，将其变成黑色
- 情况2：插入节点的父结点为黑色，直接插入
- 情况3：插入节点的父结点是红色，若叔叔节点为红色，则其祖父节点必然为黑色，将祖父节点变为红色，父结点和叔叔节点变为黑色，此时相当于插入红色的祖父节点，要重新对祖父节点进行判断
- 情况4：插入的新的红色节点的父结点是红色，如果叔叔节点是黑色，且新的系欸但在父结点右边，先以父结点进行左旋转，形成情况5
- 情况5：插入的新的红色节点的父结点是红色，如果叔叔节点是黑色，且新节点在父结点左边，则先将父结点变成黑色，但是违反了规则五，必须再将祖父节点变为红色， 以祖父节点进行右旋

删除操作一边有七种情况



左旋操作和右旋操作

不会改变二叉搜索树的性质，是调整平衡的手段

### 蛇梯棋

先架起桥梁，桥梁边权重为0

但是要解决不能连续传送的问题

当一个点是桥梁终点，则该点正常有效

当一个点是桥梁起点，则该点正常无效

所以这道题不能用Floyd算法

有没有办法用上Floyd算法

有没有办法在计算的时候发现两个连续的桥梁

用一个哈希表记录该点最短路径是否为桥梁到达？

好像依然不行，Floyd算的是每个点的最短路径，



# unordered_map



## 接雨水

第i处接的雨水等于两边最大高度的最小值减去height[i]

从左往右遍历，存每个i的左边最大高度

从右往左遍历，存每个i的右边最大高度

再次遍历，累加每个i上面的雨水





## 无重复的最长子串

找到每一个字符为起点的最大无重复子串

定一个起点

终点不断往右移动

每一次往右移动之后，都要判断终点何前面的字符是否重复，如果重复了，说明找到了当前起点最大无重复子串

然后起点右移，这时候终点不用从头开始，不需要移动，因为从p到q是无重复子串，说明从p+1到q也是无重复子串

但是这里是可以优化的，p不是变成p+1,而是移动到与q重复的元素的后面一个，因为在这之前得到的最大无重复子串也不会比q-p更长了，原先与q重复的元素还在子串里，q就无法继续向右移动

- 初始化，p=q=0;
- 进入循环，while(p<n-longest,q<n)
  - q++
  - 判断右移动之后是否仍然无重复，这里其实可以用哈希表加速，但是空间资源消耗大，感觉好处不多，没必要
  - 若无重复，继续右移动
  - 若重复，p=i+1;记录最大长度



## 最小覆盖子串

使用滑动窗口，统计从每一个字符开始的最小覆盖长度，取最小的。

当左指针指到t中没有的字符的时候，可以直接跳过，因为这样统计出来的一定不是最小。

while（l小于s.size()）{

while(l和r包围的子串为有效子串){

while(r不为有效字符或者超范围){

r++；

}

如果是超范围直接return;

}

l++;

}



- 如何判断是否为有效字符，用set建立一个t字符的哈希表
- 如何判断字符串为有效字符：维护两个哈希表，字符和个数对应，同时维护yi'ge



## 用最少数量的箭引爆气球

假设已经得到最优方法

可以想办法移动每一支箭，使得它到达一个气球的右边界，继续移动下去该气球就爆炸不了了。

所以可以通过某种方法找到这种情况的每一支箭

给每个气球按照右边界排序

找到最左边的气球，扎一支箭，引爆气球

直到所有气球被引爆



## 最小基因变化

先看end是否在bank中

检查start和end差了的字符，改变一个字符看看是否在bank中，是就删了bank中的字符，继续改变，，如果不是就换路，直到找到或者没有路



