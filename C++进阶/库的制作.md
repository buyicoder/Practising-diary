.so结尾的文件

# 库的制作

使用程序的时候用到cout，printf

函数来自于哪里

来自于头文件

头文件里面都是声明

定义的时候怎么操作

## 静态库

- 准备头文件，源文件，主程序文件
- 将源文件和主程序文件联合编译生成可执行文件
- 

库的制作

1、为什么引入库

在add.cpp中，如果项目结束后，到了交付阶段，由于主程序的生成需要其它程序联合编译，就要将源程序打包一起发给老板，这样程序员自身的价值就不大了该项目的知识产权很容易被窃取。

为了保护知识产权，引入库的概念？

2、什么是库

库在linux系统中是一个二进制文件，它是由.cpp文件（不包含main函数）编译而来，其它程序如果想要使用该源文件中的函数时，只需在编译生成可执行程序时，连接上该源文件生成的库文件即可。库中存储的是二进制文件，不容易被窃取知识产权，做到了保护作用。

库在linux系统中分为两类，分别是静态库和动态库



### 什么是静态库？

windows：静态库是***.lib,

​					动态库是***.dll

linux：

​			***.a:静态库

​			***.so:动态库

3.静态库及其制作

```
概念：将一个***.cpp的文件生成一个lib***.a的二进制文件，当你需要使用该源文件中的函数时，只需要链接该库即可，后期课直接调用
静态体现在：在使用g++编译程序时，会将文件和库最终生成可执行程序（把静态库直接放入到可执行程序中），每个可执行程序单独拥有一个静态库，体积较大，但是执行效率高
```

- 准备程序

  - add.h

  - add.c

- 编译生成静态库

```
gcc -c **.c -o ***.o
ar -crs lib***.a ***.o xxx.o ddd.0
ar:用于生成静态库

```







4.动态库J及其制作

```
概念：将一个***.cpp的文件编译生成一个lib***.so的二进制文件，当需要该源文件的函数时，只需要链接该库即可，后期可以直接调用，
动态体现在：在使用g++编译程序时，会将你的文件和库中的相关函数的索引表一起生成一个可执行程序，每个可执行程序只拥有函数的索引表，执行到对应函数时，会根据索引表，动态寻找相关库所在位置进行调用，体积较小，执行效率较低，但是可以多个
```

准备程序

编译生成动态库

```
g++ -fPIC -c ***.cpp -o ***.o
g++ -shared ***.o -o lib***.so
g++ -fPIC -shared ***.cpp -o lib***.so

```



使用第三方库

编译的时候-l加上库名

