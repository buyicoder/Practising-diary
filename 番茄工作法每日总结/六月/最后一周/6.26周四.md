## 每日计划

昨天没有调整好，今天必须要看完算法的最小生成树，产出是最小生成树的一整套C++代码

## 番茄记录

- 早起做计划，安排全天活动

  - 没有中断
  - 成果：基本写完Edge类和EdgeWeightedGraph类，还差一个返回所有边的API

- 最小生成树，

  - 中断：中途看到prim算法的复杂实现就不想管了。
  - 成果：写完了prim算法和kruskal算法

  prim算法：一种计算最小生成树的算法，

```C++
class LazyPrimMST {
private:
	vector<bool> marked;
	vector<Edge> mst;
	priority_queue<Edge> pq;
public:
	LazyPrimMST(EdgeWeightedGraph G) :marked(G.getV()) {
		visit(G, 0);
		while (!pq.empty()) {
			Edge e = pq.top();
			pq.pop();
			int v = e.either(), w = e.other(v);
			if (marked[v] && marked[w])continue;
			mst.push_back(e);
			if (!marked[v])visit(G, v);
			if (!marked[w])visit(G, w);
		}
	}
	void visit(EdgeWeightedGraph G, int v) {
		marked[v] = true;
		for (Edge e : G.adj(v))if (!marked[e.other(v)])pq.push(e);
	}
	vector<Edge> edges()const { return mst; }
	double weight() {
		double sum = 0;
		for (int i = 0; i < mst.size(); i++) {
			sum += mst[i].getWeight();
		}
		return sum;
	}
};
```

主要API就是返回最小生成树的边和计算权重和。

需要借助visit来实现，生成函数构造最小生成树

- 使用优先队列保存当前所有横向边，保证每次可以获得权重最小的横向边，加入到最小生成树中
- 使用marked标记已访问顶点
- 优先队列里面的横向边有可能随着已访问顶点的扩大而失效，所以需要判断一下。

